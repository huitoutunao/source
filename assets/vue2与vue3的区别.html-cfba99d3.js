import{_ as o,r as p,o as i,c,d,a as e,b as a,e as t}from"./app-138581c8.js";const u={},l={href:"https://v3.cn.vuejs.org/guide/migration/introduction.html",target:"_blank",rel:"noopener noreferrer"},r={href:"https://juejin.cn/post/6892295955844956167",target:"_blank",rel:"noopener noreferrer"};function v(k,n){const s=p("ExternalLinkIcon");return i(),c("div",null,[n[2]||(n[2]=d(`<h1 id="vue2-与-vue3-的区别" tabindex="-1"><a class="header-anchor" href="#vue2-与-vue3-的区别" aria-hidden="true">#</a> Vue2 与 Vue3 的区别</h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p><code>vue3</code> 发布也有一年多时间了，最近跟着官网学习了 <code>vue3</code> 的相关语法，因此来整理 <code>vue2</code> 与 <code>vue3</code> 的区别。</p><p>根据官方介绍，<code>vue3</code> 主要变化在以下几个方面：</p><ul><li>更强的性能以及更好的 <code>tree shaking</code>；</li><li>新增 <code>Composition API</code> 和 <code>setup</code>；</li><li>更好的支持 <code>TypeScript</code>；</li></ul><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h2><ol><li>实例销毁钩子函数名称区别如下：</li></ol><p>vue2：beforeDestroy 和 destroyed。</p><p>vue3：beforeUnmount 和 unmounted。</p><ol start="2"><li>vue3 新增组合式 API：</li></ol><p><code>setup()</code> 作为组件内部使用组合式 API 的入口点。</p><p>在创建组件实例时，在初始 <code>prop</code> 解析之后立即调用 <code>setup</code>。在生命周期方面，它是在 <code>beforeCreate</code> 钩子之前调用的。</p><p><code>setup</code> 生命周期钩子需要导入才能使用，例如：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted<span class="token punctuation">,</span> onUpdated<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;mounted!&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">onUpdated</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;updated!&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;unmounted!&#39;</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>组合式 API 生命周期钩子和选项式 API 生命周期钩子的映射关系如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>beforeCreate =&gt; 使用 setup()
created =&gt; 使用 setup()
beforeMount =&gt; onBeforeMount
mounted =&gt; onMounted
beforeUpdate =&gt; onBeforeUpdate
updated =&gt; onUpdated
beforeUnmount =&gt; onBeforeUnmount
unmounted =&gt; onUnmounted
activated =&gt; onActivated
deactivated =&gt; onDeactivated
errorCaptured =&gt; onErrorCaptured
renderTracked =&gt; onRenderTracked
renderTriggered =&gt; onRenderTriggered
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="响应式原理" tabindex="-1"><a class="header-anchor" href="#响应式原理" aria-hidden="true">#</a> 响应式原理</h2><p>vue3 使用 <code>Proxy</code> 代替了 <code>Object.defineProperty()</code>。因为 vue2 使用它导致无法深层跟踪数组对象的变化，如果在定义对象后添加了属性，是不会触发更新渲染的。</p><p>它们两者兼容性比较：</p><ul><li>vue2 不兼容 IE8 以下浏览器，因为 <code>Object.defineProperty()</code> 语法。</li><li>vue3 不兼容 IE11 浏览器，因为 <code>Proxy</code> 语法。</li></ul><h2 id="typescript-支持" tabindex="-1"><a class="header-anchor" href="#typescript-支持" aria-hidden="true">#</a> TypeScript 支持</h2><p>vue3 内部全面使用 typescript 重构，使它有出色的 typescript 支持。对于规模较大的项目，降低了后期维护成本。</p><h2 id="打包体积优化" tabindex="-1"><a class="header-anchor" href="#打包体积优化" aria-hidden="true">#</a> 打包体积优化</h2><p>vue2 有时会把不必要的依赖打包进去，随着项目不断扩大，后期打包的体积会越来越大。</p><p>vue3 优化了这个缺陷，引用尤大大的话语：</p><blockquote><p>在 Vue3 中，我们通过将大多数全局 API 和内部帮助程序移动到 Javascript 的 <code>module.exports</code> 属性上实现这一点。这允许现代模式下的 module bundler 能够静态地分析模块依赖关系，并删除与未使用的 <code>module.exports</code> 属性相关的代码。模板编译器还生成了对 tree shaking 友好的代码，只有在模板中实际使用某个特性时，该代码才导入该特性的帮助程序。</p></blockquote><blockquote><p>尽管增加了许多新特性，但 Vue3 被压缩后的基线大小约为 10KB，不到 Vue2 的一半。</p></blockquote><h2 id="其他细节" tabindex="-1"><a class="header-anchor" href="#其他细节" aria-hidden="true">#</a> 其他细节</h2>`,28)),e("p",null,[e("a",l,[n[0]||(n[0]=a("详情请看 vue2 的迁移指南",-1)),t(s)])]),n[3]||(n[3]=e("h2",{id:"参考文献",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考文献","aria-hidden":"true"},"#"),a(" 参考文献")],-1)),e("ul",null,[e("li",null,[e("a",r,[n[1]||(n[1]=a("Vue3 对比 Vue2.x 差异性、注意点、整体梳理，与React hook比又如何？",-1)),t(s)])])])])}const b=o(u,[["render",v],["__file","vue2与vue3的区别.html.vue"]]);export{b as default};
